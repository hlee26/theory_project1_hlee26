# -*- coding: utf-8 -*-
"""2SAT_Solver_hlee26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qzgDWM0ji7mExakHG8BiHNHGkyQswvDF
"""

!pip install matplotlib

#Import libraries
import time
import matplotlib.pyplot as plt
from google.colab import files

#Define functions

# write function for unit propogation to assign values to unit clauses
def unit_prop(clauses, assignment):
    while True:
        # find unit clauses
        unitClauses = [clause for clause in clauses if len(clause) == 1]
        if not unitClauses:
            break
        # assign value based on unit literal and simplified clauses
        for unit in unitClauses:
            literal = unit[0]
            assignment[abs(literal)] = (literal > 0)
            clauses = simplify(clauses, literal)

    return clauses, assignment

# function for pure literal elimination
def pure_lit_elim(clauses, assignment):
    all_lits = [literal for clause in clauses for literal in clause]
    #find pure literals
    pure_lits = set(literal for literal in all_lits if -literal not in all_lits)
    #assign value
    for literal in pure_lits:
        assignment[abs(literal)] = (literal > 0)
        clauses = simplify(clauses, literal)

    return clauses, assignment

# simplify clause
def simplify(clauses, literal):
    new = []
    for clause in clauses:
        if literal in clause:
            continue
        new_c = [l for l in clause if l != - literal]
        new.append(new_c)

    return new

# implement dpll algorithm
def dpll(clauses, assignment):
    # call unit prop and pure literal elimination
    clauses, assignment = unit_prop(clauses, assignment)
    clauses, assignment = pure_lit_elim(clauses, assignment)
    # check is clauses are satisfied
    if not clauses:
        return True, assignment
    # check for empty clauses
    if any(len(clause) == 0 for clause in clauses):
        return False, assignment

    # recursivly try true and false assignments
    x = abs(clauses[0][0])
    for i in [True, False]:
        assignment[x] = i
        simplified = simplify(clauses, x if i else -x)
        result, final_assign = dpll(simplified, assignment.copy())
        if result:
            return True, final_assign

    return False, assignment

# call algorithm to solve 2SAT
def two_sat_solver(clauses, variables):
    assignment = {i: None for i in range(1, variables + 1)}
    result, final = dpll(clauses, assignment)

    return result, final

# plot function
def plot_results(sat_variables, sat_times, unsat_variables, unsat_times):
    plt.figure(figsize=(10, 6))

    # plot satisfiable cases
    plt.plot(sat_variables, sat_times, marker='o', linestyle='None', color='g', label='Satisfiable')

    # plot unsatisfiable cases
    plt.plot(unsat_variables, unsat_times, marker='x', linestyle='None', color='r', label='Unsatisfiable')

    plt.title('2-SAT Solver Performance')
    plt.xlabel('Number of Variables')
    plt.ylabel('Time (seconds)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Main function
def main(file_path):
#  plot_results(test_case_variables, test_case_times)
    clauses = []
    variables = 0
    current_clauses = []
    test_case_count = 0
    test_case_times = []
    test_case_variables = []

    # separate lists for satisfiable and unsatisfiable
    sat_times = []
    unsat_times = []
    sat_variables = []
    unsat_variables = []

    # code to open file and read in
    with open(file_path, 'r') as file:
      # loop through every test case
        for line in file:
            line = line.lstrip('\ufeff').strip()

            if line.startswith('c'): # skip comment lines
                continue
            elif line.startswith('p'): # problem def line
                if current_clauses:
                # solve test case and measure time
                    start_time = time.time()
                    result, assignment = two_sat_solver(current_clauses, variables)
                    end_time = time.time()

                    elapsed_time = end_time - start_time
                    test_case_count += 1

                    if result:
                        print(f"Test Case {test_case_count}: Satisfiable")
                        sat_times.append(elapsed_time)
                        sat_variables.append(variables)
                    else:
                        print(f"Test Case {test_case_count}: Unsatisfiable")
                        unsat_times.append(elapsed_time)
                        unsat_variables.append(variables)

                    current_clauses = []

                parts = line.replace(",", " ").split()
                if len(parts) == 4 and parts[0] == 'p' and parts[1] == 'cnf':
                    variables = int(parts[2])
            else:
              # parse lines
                try:
                    clause = [int(literal) for literal in line.replace(",", " ").split() if int(literal) != 0]
                    current_clauses.append(clause)
                except ValueError:
                    print(f"Skipping invalid line: {line}")
                    continue

        # last test case
        if current_clauses:
            start_time = time.time()
            result, assignment = two_sat_solver(current_clauses, variables)
            end_time = time.time()

            elapsed_time = end_time - start_time
            test_case_count += 1

            if result:
                print(f"Test Case {test_case_count}: Satisfiable")
                sat_times.append(elapsed_time)
                sat_variables.append(variables)
            else:
                print(f"Test Case {test_case_count}: Unsatisfiable")
                unsat_times.append(elapsed_time)
                unsat_variables.append(variables)

    plot_results(sat_variables, sat_times, unsat_variables, unsat_times)

# upload file
uploaded = files.upload()

# get bame of uploaded file
file_name = next(iter(uploaded))

# call main with file name
main(file_name)